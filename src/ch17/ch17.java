package ch17;

/*
 * ch17. 냄새와 휴리스틱
 *
 * # 주석
 * C1: 부적절한 정보
 *  다른 시스템에 저장할 정보는 주석으로 X
 *  ex) 변경 이력
 *  작성자, 최종 수정일, SPR 번호 등의 메타 정보만
 *
 * C2: 쓸모 없는 주석
 *  쓸모 없어질 주석은 아예 달지 않고,
 *  쓸모 없어진 주석은 빠르게 삭제
 *
 * C3: 중복된 주석
 *  코드로 설명할 수 있다면 추가 주석 X
 *
 * C4: 성의 없는 주석
 *  작성할 가치가 있는 주석은 잘 작성할 가치도 있음
 *  최대한 멋지게, 단어를 신중하게, 문법과 구두점을 올바르게, 간단명료하게
 *
 * C5: 주석 처리된 코드
 *  소스코드 관리 시스템이 기억하므로 주석처리 코드는 삭제
 *
 * # 환경
 * E1: 여러 단계로 빌드해야 한다
 *  한 명령으로 전체를 체크아웃해서 한 명령으로 빌드할 수 있어야 함
 *
 * E2: 여러 단계로 테스트해야 한다
 *  모든 단위 테스트는 한 명령으로 돌려야 함
 *  모든 테스트를 한번에 실행하는 것은 빠르고, 쉽고 명백해야 함
 *
 * # 함수
 * F1: 너무 많은 인수
 *  인수 개수는 작을수록 좋음
 *
 * F2: 출력 인수
 *  일반적으로 인수는 입력
 *  상태 변경은 속한 객체의 상태를 변경해야
 *
 * F3: 플래그 인수
 *  플래그 인수는 함수가 여러 기능을 수행한다는 증거
 *  플래그 인수 사용 X!!
 * 
 * F4: 죽은 함수
 *  호출하지 않는 함수는 삭제
 *  코드 관리 시스템이 기억
 *
 * # 일반
 * G1: 한 소스 파일에 여러 언어를 사용한다
 *  이상적으로는 소스 파일 하나당 언어 하나만 사용
 *  최대한 언어 수와 범위 줄여야 함
 * 
 * G2: 당연한 동작을 구현하지 않는다
 *  최소 놀람의 원칙(The Principle of Least Surprise)에 의거
 *  함수나 클래스는 당연하게 여길 동작과 기능을 제공해야 함
 * 
 * G3: 경계를 올바로 처리하지 않는다
 *  모든 경계 조건을 찾아내고 테스트하는 테스트 케이스를 작성해야 함
 *
 * G4: 안전 절차 무시
 *  컴파일러 경고, 실패하는 테스트케이스를 무시하면 안됨
 * 
 * G5: 중복
 *  코드 중복 == 추상화할 기회
 *
 *  코드 중복 => 간단한 함수로 교체
 *  같은 조건 확인하는 중복 => 다형성으로 대체
 *  알고리즘은 유사하지만 코드가 다름 => TEMPLATE METHOD 패턴 or STRATEGY 패턴
 *
 * G6: 추상화 수준이 올바르지 못하다
 *  모든 저차원 개념은 파생 클래스에,
 *  모든 고차원 기념은 기초 클래스에
 *  잘못된 추상화는 적당히 수정 불가
 *
 * G7: 기초 클래스가 파생 클래스에 의존한다
 *  기초 클래스와 파생 클래스로 분리하는 이유
 *  : 고차원 클래스 기념을 저차원 클래스 개념으로부터 분리해 독립성 보장
 *  기초 클래스는 파생 클래스를 몰라야 함
 *
 * G8: 과도한 정보
 *  잘 정의된 모듈은 인터페이스가 아주 작고, 그럼에도 많은 동작이 가능하며, 결합도가 낮음
 *  클래스 메소드 수, 함수가 아는 변수 수, 클래스 인스턴스 변수 수는 작을수록 좋음
 *  자료 숨기고, 유틸리티 함수를 숨기고, 상수와 임시 변수 숨겨야 함'
 *
 * G9: 죽은 코드
 *  실행되지 않는 코드를 제거
 *
 * G10: 수직 분리
 *  변수와 함수는 사용 위치 가까이 정의
 *  지역변수는 처음 사용하기 직전에 선언
 *  비공개 함수는 처음 호출한 직후 정의
 *
 * G11: 일관성 부족
 *  어떤 개념을 특정 방식으로 구현
 *  -> 유사 개념도 같은 방식으로 구현
 *  최소 놀람의 원칙에도 부합
 *
 * G12: 잡동사니
 *  아무도 사용하지 않는 변수, 호출하지 않는 함수, 정보를 제공하지 못하는 주석 등
 *  모두 제거
 *
 * G13: 인위적 결합
 *  서로 무관한 개념을 인위적으로 결합 X
 *  일반적으로 직접적인 상호작용이 없는 두 모듈간 뚜렷한 목적 없이 당장 편한 위치에 변수, 상수, 함수를 넣어버린 결과
 *
 * G14: 기능 욕심
 *  클래스 메소드는 자기 클래스의 변수와 함수에 관심
 *  다른 클래스 변수와 함수에 관심 가지면 안됨
 *  메소드가 참조자, 변경자로 객체 내용을 조작하는 것은 월권행위
 *
 * G15: 선택자 인수
 *  선택자 인수 대신 함수를 쪼개야 함
 *  boolean, int, enum 등 함수 동작 제어 인수는 바람직하지 않음
 * 
 * G16: 모호한 의도
 *  코드 의도를 분명히 밝혀야 함
 *  행바꿈 없이, 헝가리 표기, 매직 번호 등 사용 X
 *
 * G17: 잘못 지운 책임
 *  개발자의 중요 결정 중 하나 : 코드의 위치
 *  최소 놀람의 원칙 적용
 *  코드는 독자가 기대할 위치에 배치
 *  때로는 독자에게 직관적인 위치 X 개발자에게 편한 함수에 배치 O
 *   결정법. 함수 이름 확인
 *
 * G18: 부적절한 static 함수
 *  알고리즘이 여러 개라 함수 재정의할 가능성이 있는 경우 static 부적절
 *  일반적으로 static 함수보다는 인스턴스 함수가 나음
 *
 * G19: 서술적 변수
 *  프로그램 가독성을 높이는 가장 효과적인 방법 중 하나
 *  : 계산을 여러 단계로 나누고, 중간 값으로 서술적 변수명을 사용
 *
 * G20: 이름과 기능이 일치하는 함수
 *  이름만으로 분명하지 않으면 더 좋은 이름으로 바꾸거나 기능을 정리
 *
 * G21: 알고리즘을 이해하라
 *  함수가 돌아가는 방식을 확실히 이해
 *  테스트케이스를 모두 통과하는 것만으로는 불충분
 *  작성자가 확신해야 함
 * 
 * G22: 논리적 의존성은 물리적으로 드러내라
 *  모듈이 다른 모듈에 의존한다면 물리적 의존성도 존재
 *  의존하는 모듈이 상대를 가정하면 안 됨
 *  의존하는 모든 정보를 명시적으로 요청
 *
 * G23: If/Else 혹은 Switch/Case 문보다 다형성을 사용하라
 *  1. 대다수 개발자가 switch 문을 사용하는 이유는
 *     그저 손쉬운 선택이기 때문
 *  2. 유형보다 함수가 더 쉽게 변하는 경우는 극히 드묾
 *  선택 유형 하나에는 switch 문 한 번만 사용
 *
 * G24: 표준 표기법을 따르라
 *  팀은 업계 표준에 기반한 구현 표준을 따라야 함
 *  팀이 정한 표준은 팀원 모두가 따라야 함
 *
 * G25: 매직 숫자는 명명된 상수로 교체하라
 *  코드에서 숫자를 사용하지 말라는 규칙
 *  숫자는 명명된 상수 뒤로 숨기라는 의미
 *
 * G26: 정확하라
 *  검색 결과 중 첫 번째 결과만 유일한 결과 취급 X
 *  부동 소수점으로 통화 표현 X
 *  갱신 가능성이 희박하다고 잠금과 트랜젝션 관리 안하기 X
 *  List를 ArrayList로 선언 X
 *  모든 변수를 protected로 선언 X
 *
 *  코드에서 무언가를 결정할 때는 정확하게
 *  모호성과 부정확은 제거
 *
 * G27: 관례보다 구조를 사용하라
 *  명명 관례보다는 구조 자체로 강제
 *  ex) enum을 사용한 switch/case 보다는 추상 메소드가 있는 기초 클래스
 *
 * G28: 조건을 캡슐화하라
 *  부울 논리는 이해가 까다로움
 *  조건의 의도를 분명히 밝히는 함수로 표현
 *
 * G29: 부정 조건은 피하라
 *  부정 조건은 긍정보다 이해 힘듦
 *  가능하면 긍정 조건으로 표현
 *
 * G30: 함수는 한 가지만 해야 한다
 *  한 가지만 수행하는 더 작은 함수 여럿으로 나눠야 함
 *
 * G31: 숨겨진 시간적인 결합
 *  시간적인 결합을 숨기면 안 됨
 *  함수 인수를 적절히 배치해 함수가 호출되는 순서를 명백히 드러냄
 *  의도적으로 복잡성을 추가해서 시간 결합을 드러내고 순서 변경을 막음
 *
 * G32: 일관성을 유지하라
 *  코드 구조를 잡을 때는 이유를 고민하고 코드 구조로 명백히 표현
 *  시스템 전반에 걸쳐 일관성이 있다면 남들도 따름
 *
 * G33: 경계 조건을 캡슐화하라
 *  경계 조건을 한 곳에서 별도로 처리
 *  다시말해, 코드 여기저기에 +1, -1 등을 흩어놓지 않음
 *
 * G34: 함수는 추상화 수준을 한 단계만 내려가야 한다
 *  함수 내 모든 문장은 동일한 추상화 수준
 *  추상화 수준은 함수 이름이 의미하는 작업보다 한 단계 낮아야 함
 * 
 * G35: 설정 정보는 최상위 단계에 둬라
 *  추상화 최상위 단계에 둬야 할 기본값 상수나 설정 관련 상수를
 *  저차원 함수에 숨기면 안 됨
 *  고차원 함수에서 저차원 함수를 호출할 때 인수로 넘김
 *  
 *  설정 관련 상수는 최상위 단계에 둠
 *
 * G36: 추이적 탐색을 피하라
 *  일반적으로 모듈은 주변 모듈을 모를수록 좋음
 *  : 디미터의 법칙, 부끄럼 타는 코드 작성
 *  사용하는 모듈이 필요한 모든 서비스를 제공해야 함
 *
 * # 자바
 * J1: 긴 import 목록을 피하고 와일드카드를 사용하라
 *  클래스를 둘 이상 사용한다면 와일드카드를 사용해 패키지 전체를 가져오라
 *  명시적 클래스 import는 강한 의존성을 생성해서 클래스가 반드시 존재해야 함
 *  와일드카드는 특정 클래스가 반드시 존재할 필요는 없고 진정한 의존성이 생기지 않아 결합성이 낮아짐
 *  
 *  이름이 같은 패키지 OR 클래스 사용 시
 *  전체 경로 명시 OR 명시적 import 사용
 * 
 * J2: 상수는 상속하지 않는다
 *  상수를 상속 계층에 숨겨놓는 것은 쓰레기짓
 *  차라리 static import 사용
 *
 * J3: 상수 대 Enum
 *  enum은 강력한 도구이므로 마음껏 활용
 *
 * # 이름
 * N1: 서술적인 이름을 사용하라
 *  서술적인 이름을 신중하게
 *  이름이 소프트웨어 가독성의 90%를 책임
 *
 * N2: 적절한 추상화 수준에서 이름을 선택하라
 *  구현을 드러내는 이름 X
 *  작업 대상 클래스나 함수가 위치한 추상화 수준을 반영하는 이름 O
 *  뒤섞인 추상화 발견할 때마다 수정해야 함
 *
 * N3: 가능하다면 표준 명명법을 사용하라
 *  기존 명명법을 사용한 이름은 이해가 더 쉬움
 *  팀에서 적용할 표준 : 유비쿼터스 언어
 *
 * N4: 명확한 이름
 *  함수나 변수의 목적을 명확히 밝히는 이름 선택
 *  한 번만 호출된다면 길다는 단점을 서술성이 충분히 메꿈
 *
 * N5: 긴 범위는 긴 이름을 사용하라
 *  이름 길이는 범위에 비례해야 함
 *  범위가 5줄 안 -> i, j 등 사용해도 괜찮음
 *  긴 범위 -> 정확하고 긴 이름
 *
 * N6: 인코딩을 피하라
 *  이름에 유형 정보나 범위 정보를 넣으면 안 됨
 *  m_, f 등 접두어는 불필요
 *  헝가리안 표기법 X
 *
 * N7: 이름으로 부수 효과를 설명하라
 *  함수, 변수, 클래스가 하는 일을 모두 기술하는 이름 사용
 *  부수 효과 숨기기 X
 *  ex) getOos X -> createOrReturnOos O
 *
 * # 테스트
 * T1: 불충분한 테스트
 *  테스트케이스는 잠재적으로 깨질만한 부분을 모두 테스트
 *  확인하지 않는 조건, 검증하지 않는 계산 -> 불환전한 테스트
 *
 * T2: 커버리지 도구를 사용하라!
 *  커버리지 도구는 테스트가 빠뜨리는 공백을 알려줌
 *  커버리지 도구를 사용하면 테스트가 불충분한 모듈, 클래스, 함수를 찾기 쉬워짐
 *  대다수 IDE가 시각적으로 표현해줌
 *
 * T3: 사소한 테스트를 건너뛰지 마라
 *  사소한 테스트가 제공하는 가치 >> 구현 비용
 *
 * T4: 무시한 테스트는 모호함을 뜻한다
 *  요구사항이 불분명해서 프로그램이 돌아가는 방식을 확신하기 어려움
 *  불분명한 요구사항은 테스트 케이스에 주석처리 OR @Ignore
 *
 * T5: 경계 조건을 테스트하라
 *  경게 조건은 신경써서 테스트
 *  매우 흔한 실수
 *
 * T6: 버그 주변은 철저히 테스트하라
 *  버그는 모이는 경향을 보임
 *  버그 발생 함수를 철저히 테스트
 * 
 * T7: 실패 패턴을 살펴라
 *  테케가 실패하는 패턴으로 문제 진단 가능
 *  -> 테케를 최대한 꼼꼼히 짜야하는 이유
 * 
 * T8: 테스트 커버리지 패턴을 살펴라
 *  통과하는 테스트가 실행하거나 실행하지 않는 코드
 *  -> 실패 테케 원인
 *
 * T9: 테스트는 빨라야 한다
 *  느린 테케는 잘 실행 안하게 됨
 *  최대한 빠르게 돌아가도록
 * 
 * # 결론
 * 규칙만 따른다고 깨끗한 코드가 되지 않음
 * 가치에 기반한 규율과 절제가 필요
 *
 *
 *
 */
public class ch17 {
}
