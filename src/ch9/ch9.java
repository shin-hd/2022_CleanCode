package ch9;

/*
 * ch9. 단위 테스트
 * 애자일, TDD
 * => 테스트 자동화, 제대로 된 테스트 케이스
 *
 * # TDD 법칙 세 가지
 * 1. 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다
 * 2. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다
 * 3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다
 * 
 * 테스트 코드가 실제 코드만큼 나와서 관리 문제 유발하기도 함
 * 
 * # 깨끗한 테스트 코드 유지하기
 * 지저분한 코드 >> 쓰레기 테스트 코드
 * 쓰레기 테스트 코드 + 누적 버전 => 유지보수 비용 폭등 => 테스트 코드 폐기
 * 테스트 코드 중요성 === 실제 코드 중요성
 *
 * - 테스트는 유연성, 유지보수성, 재사용성을 제공
 * 테스트 케이스가 없다면 모든 변경점이 잠정적 버그
 * 테스트 케이스가 있다면 변경이 쉬워짐
 * 단위 테스트는 유연성, 유지보수성, 재사용성의 버팀목
 * 
 * # 깨끗한 테스트 코드
 * 깨끗한 테스트 코드가 필요한 세가지, 가독성*3
 * 가독성 <= 명료성 + 단순성 + 표현력
 *
 * - 도메인에 특화된 테스트 언어
 * DSL은 시스템 조작 API가 아닌 테스트 코드에서 사용하는 특수 API, 테스트 언어
 * - 이중 표준
 * 테스트 API 코드 표준 !== 실제 코드 표준
 * 테스트 표준은 단순, 간결, 표현력 풍부, 효율은 좀 떨어져도 됨
 * 테스트 환경에서는 메모리, CPU 효율을 덜 따짐
 *
 * # 테스트 당 assert 하나
 * assert 하나 -> 결론이 하나 : 이해가 쉽고 빠름
 * given-when-then
 * TEMPLATE METHOD 패턴으로 중복 제거
 *  given/when 부모 클래스   then 자식 클래스
 *  given/when @Before     then @TEST
 * 그냥 assert 여럿이 나을 수도
 *
 * # 테스트 당 개념 하나
 * assert가 여럿이라는 것이 문제가 아님
 * 한 테스트 함수에서 여러 개념을 테스트하는 것이 문제
 *
 * # F.I.R.S.T.
 * 깨끗한 테스트 다섯 규칙
 * Fast 빠르게
 * Independent 독립적
 * Repeatable 반복가능
 * Self-Validating 자가검증 (성공/실패)
 * Timely 적시에
 *
 * # 결론
 * 핑계대지말고 그냥 깨끗한 테스트 코드 짜라
 *
 */
public class ch9 {
}
