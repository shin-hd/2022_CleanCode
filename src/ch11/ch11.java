package ch11;

/*
 * ch11. 시스템
 * 복잡성은 죽음이다.
 *
 * # 도시를 세운다면?
 * 큰 그림 전문 + 세부 사항 전문
 * 도시 시스템 <= 추상화 + 모듈화
 * 소프트웨어 시스템 := 도시 시스템
 *
 * # 시스템 제작과 시스템 사용을 분리하라
 * 제작 != 사용
 * 준비과정 // 런타임 로직 분리
 * 관심사 분리!
 * 체계적이고 탄탄한 시스템
 * : 좀스럽고 손쉬운 기법으로 모듈성 깨면 안됨
 * 설정 논리와 일반 실행 논리를 분리
 * 전반적이고 일관적인 방식도 필요
 * 
 * - Main 분리
 * 생성과 관련된 코드는 모두 main이나 main이 호출하는 모듈에
 * 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다 가정
 *
 * - 팩토리
 * 객체가 생성되는 시점을 애플리케이션이 결정
 * => ABSTRACT FACTORY 패턴
 * 애플리케이션이 인스턴스를 생성하지만 생성하는 내부 코드는 모름
 *
 * - 의존성 주입(DI)
 * 제어 역전 (IOC) 기법을 의존성 관리에 적용
 * DI 컨테이너가 필요한 객체 인스턴스를 만들고 생성자 인수나 설정자 메소드를 사용해 의존성 설정
 * 생성 객체 유형은 설정 파일에서 지정하거나 특수 생성 모듈에서 코드로 명시
 *
 * # 확장
 * 처음부터 올바른 시스템 X
 * 시스템을 조정하고 확장 <= 애자일
 * 
 * 비즈니스 논리가 큰 컨테이너와 밀접하게 결합
 *
 * - 횡단(cross-cutting) 관심사
 * AOP는 횡단 관심사에 대처해 모듈성을 확보하는 일반적인 방법론
 * 영속적으로 저장할 객체와 속성을 선언하고 영속성 책임을 영속성 프레임워크에 위임
 * AOP 프레임워크는 대상 코드에 영향을 미치지 않는 상태로 동작 방식 변경
 * 
 * 자바에서 사용하는 관점 혹은 유사 매커니즘 세 가지
 * 1. 자바 프록시
 * 단순한 상황에 적합
 * JDK 동적 프록시는 인터페이스만 지원
 * 클래스 프록시는 CGLIB, ASM, Javassist 등의 바이트 코드 처리 라이브러리 필요
 * 프록시 단점 : 코드 양, 코드 크기
 *
 * 2. 순수 자바 AOP 프레임워크
 * 순수 자바 관점을 구현하는 프레임워크는 내부적으로 프록시 사용
 * 스프링은 비즈니스 논리를 POJO로 구현
 * POJO는 순수 도메인에 초점
 * 스프링 관련 자바 코드가 없어 애플리케이션은 스프링과 독립적
 * XML은 장황하고 읽기 어렵지만 설정 관리가 단순
 *
 * 3. AspectJ 관점
 * 언어 차원에서 관점을 모듈화 구성으로 지원하는 자바 언어 확장
 * 새 도구와 새 문법 및 사용법을 익혀야 한다는 단점
 *
 * # 테스트 주도 시스템 아키텍처 구축
 * 소프트웨어 구조가 관점을 효과적으로 분리한다면, 극적인 변화가 경제적으로 가능
 * 단순하고 멋지게 분리된 아키텍쳐로 개발한 다음 기반 구조를 추가하며 조금씩 확장
 *
 * # 의사 결정을 최적화하라
 * 모듈을 나누고 관심사를 분리하면 지엽적인 관리와 결정이 가능
 * 최대한 정보가 모이도록 가능한 마지막 순간까지 결정을 미루는 방법이 최선
 *
 *
 * # 명백한 가치가 있을 때 표준을 현명하게 사용하라
 * 표준과 고객 가치를 잘 저울질해야함
 *
 * # 시스템은 도메인 특화 언어가 필요하다
 * DSL : 간단한 스크립트 언어나 표준 언어로 구현한 API
 * 추상화 수준을 코드 관용구나 디자인 패턴 이상으로 끌어올림
 * 
 * # 결론
 * 깨끗하지 못한 시스템 > 도메인 논리 흐림 > 기민성 떨어짐 > 품질, 생산성 저하 > TDD 제공 이점 사라짐
 * 시스템이든 모듈이든, 가장 단순한 수단을 사용
 *
 */

public class ch11 {
}
